<html>
  <head>
    <title>Танчики</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
      #info {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 100;
        display:block;
        color: red;
        font-weight: bold;
        font-size: 30px;
      }
    </style>
  </head>
  <body>
    <div id="info">Танчики</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/90/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.10/lodash.min.js" integrity="sha256-/GKyJ0BQJD8c8UYgf7ziBrs/QgcikS7Fv/SaArgBcEI=" crossorigin="anonymous"></script>
    <script type="text/javascript" src="./channels.js"></script>
    <script type="text/javascript" src="./3d_objects.js"></script>

    <script type="text/javascript">
      async function rotateSampleTank(){
        let tank = createTank()
        scene.add( tank );

        while(true){
          tank.rotation.x += 0.01;
          tank.rotation.y += 0.05;
          await animationChannel.promise
        }
      }

      async function runControlledTank({speed=0.1, onKeyPressed=null, color=0x00ee00, startX=0, startY=0}={}){
        let tank = createTank({color})
        scene.add( tank );

        tank.position.x += startX * speed;
        tank.position.y += startY * speed;

        if (!onKeyPressed)
          return

        const onkeydownOldHandler = document.onkeydown
        document.onkeydown = (event)=>{
          if (onkeydownOldHandler){
            onkeydownOldHandler(event)
          }
          checkKey(event);
        }

        let direction = 0;
        const DIRECTION_TO_MOVEMENT = {
          0: [-1, 0],
          1: [0, -1],
          2: [1, 0],
          3: [0, 1],
        }

        function checkKey(e) {
          e = e || window.event;

          console.log('e.key', e.key)
          console.log('e.keyCode', e.keyCode)

          let [newDirection, movement] = onKeyPressed(e)

          if (!_.isNull(newDirection)){
            direction = newDirection
          }

          tank.rotation.z = direction * Math.PI /2;

          if (!_.isNull(movement)){
            let [dx, dy] = DIRECTION_TO_MOVEMENT[direction]
            tank.position.x += dx * speed;
            tank.position.y += dy * speed;
          }

          tank.position.x = Math.max(leftX, tank.position.x)
          tank.position.x = Math.min(rightX, tank.position.x)
          tank.position.y = Math.max(bottomY, tank.position.y)
          tank.position.y = Math.min(topY, tank.position.y)
        }
      }
    </script>
    <script>
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      document.body.appendChild( renderer.domElement );




      var borderMaterial = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } );
      var borderGeometry = new THREE.Geometry();
      window.leftX = -13;
      window.rightX = 13;
      window.topY = 6;
      window.bottomY = -7;
      borderGeometry.vertices.push(new THREE.Vector3( leftX, topY, 0) );
      borderGeometry.vertices.push(new THREE.Vector3( rightX, topY, 0) );
      borderGeometry.vertices.push(new THREE.Vector3( rightX, bottomY, 0) );
      borderGeometry.vertices.push(new THREE.Vector3( leftX, bottomY, 0) );
      borderGeometry.vertices.push(new THREE.Vector3( leftX, topY, 0) );
      var border = new THREE.Line( borderGeometry, borderMaterial );
      scene.add( border );

      camera.position.z = 17;

      var light = new THREE.PointLight(0xFFFF00);
      /* position the light so it shines on the cube (x, y, z) */
      light.position.set(10, 0, 25);
      light.castShadow = true;
      light.shadow.mapSize.width = 1024;
      light.shadow.mapSize.height = 1024;
      scene.add(light);

      window.animationChannel = new Channel(requestAnimationFrame)

      async function render(){
        while(true){
          renderer.render(scene, camera);
          await animationChannel.promise
        }
      }

      // rotateSampleTank()

      runControlledTank({
        speed: 1,
        color: 0x990099,
        startX: 0,
        startY: 10,
        onKeyPressed: (event)=>{
          if (event.keyCode == '38') {
            return [3, null] // up
          }
          else if (event.keyCode == '40') {
            return [1, null] // down, zero step
          }
          else if (event.keyCode == '37') {
            return [0, null] // left, zero step
          }
          else if (event.keyCode == '39') {
            return [2, null] // right, zero step
          }
          else if (event.keyCode == '32') {
            return [null, 1] // space
          }
          return [null, null]
        }
      })


      runControlledTank({
        speed: 1,
        color: 0xeeee00,
        startX: 0,
        startY: 10,
        onKeyPressed: (event)=>{
          if (event.keyCode == '87') {
            return [3, null] // w
          }
          else if (event.keyCode == '83') {
            return [1, null] // s, zero step
          }
          else if (event.keyCode == '65') {
            return [0, null] // a, zero step
          }
          else if (event.keyCode == '68') {
            return [2, null] // d, zero step
          }
          else if (event.keyCode == '192') {
            return [null, 1] // `
          }
          return [null, null]
        }
      })

      render()
    </script>
  </body>
</html>
